\documentclass[notes]{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[catalan]{babel}
\usepackage{amsmath,amsthm,amssymb}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{tikz}
\usetikzlibrary{cd}

\usetheme{Boadilla}

\newcommand{\cat}[1]{\mathcal{#1}}
\newcommand{\id}{\mathrm{id}}

\DeclareMathOperator{\Obj}{Obj}

\title{Monads in Haskell}
\author{Claudi Lleyda Moltó}
\institute[UAB]{Universitat Autònoma de Barcelona}
\date{}

\begin{document}
\begin{frame}
    \titlepage
\end{frame}

\section{Introduction}

\begin{frame}{Motivation}
    Functions in computer programming are not mathematical functions.
    \note<1>{They do all sort of weird things, like
        \begin{itemize}
            \item Return different outputs for the same inputs (not well
                defined)
            \item Modify global state (very foreign to mathematics)
        \end{itemize}
    }

    \pause

    \begin{itemize}
        \item reading from memory
        \item writing to memory
    \end{itemize}
    \note<2>{These can be all expressed in terms of memory IO, outside their
    inputs}

    \pause

    If they were, we could better reason about code and get benefits
    \note<3>{We is the compiler\par}
    \begin{itemize}
        \item memorization
        \item automatic parallelization
    \end{itemize}
    \note<3>{Explain memorization and parallelization\par}
    \note<3>{other benefits include code safety
        \begin{itemize}
            \item not letting your functions interfere with others
            \item not letting your functions be affected by the effects of
                others
        \end{itemize}
    }
\end{frame}

\begin{frame}{Definitions}
    \note{Definitions from the original report\par}
    \begin{definition}[Procedure]
        We call functions in computer programming~\emph{procedures}.
    \end{definition}
    \note<1>{We may call simply them functions if the context is clear}

    \pause

    \begin{definition}[Pure function]
        If a procedure reads from memory we say it is~\emph{non-deterministic},
        and if it writes to memory we say it has~\emph{side-effects}.

        We say that a procedure that is deterministic and does~\alert{not} have
        side-effects is a~\emph{pure} function.
    \end{definition}
    \note<2>{Pure functions behave like mathematical functions, and we can treat
    them like such when reasoning}
\end{frame}

\section{Kleisli triples}

\begin{frame}{Purifying functions: Examples}
    We can make an impure function pure by changing its codomain.

    \note{Impure functions in Set can be viewed as pure in an appropriate
    category}

    \pause

    \begin{example}[Non-determinism]
        If~\(\tilde{f}:A\longrightarrow B\) is non-deterministic, we can define
        a function of all possible outputs
        \[
            f:A\longrightarrow\mathcal{P}(B)
        \]
        which becomes deterministic
    \end{example}

    \pause

    \begin{example}[Side-effects]
        If~\(\tilde{f}:A\longrightarrow B\) has side-effects, we can define a
        function to track the effects on the set of states~\(S\) and the result
        \[
            f:A\longrightarrow(S\times B)^{S}
        \]
        which has no side-effects.
    \end{example}
\end{frame}

\begin{frame}{Purifying functions: Generalization}
    \begin{definition}[Kleisli triples]
        We define a~\emph{Kleisli triple} over a category~\(\cat{C}\) as a
        triple~\((T,\eta,(-)^{\ast})\) consisting of
        \begin{enumerate}
            \item a class function
                \(T:\Obj(\cat{C})\longrightarrow\Obj(\cat{C})\).

            \item for all~\(A\in\cat{C}\)
                a morphism~\(\eta_{A}:A\longrightarrow TA\)
                in~\(\cat{C}\).

            \item for all~\(f:A\longrightarrow TB\) a
                morphism~\(f^{\ast}:TA\longrightarrow TB\).
        \end{enumerate}
        such that
        \begin{enumerate}
            \item for all~\(A\in\cat{C}\) we have
                \({\eta_{A}}^{\ast} = \id_{TA}:TA\longrightarrow TA\).

            \item for all~\(A,B\in\cat{C}\) and \(f:A\longrightarrow TB\) we
                have~\(f^{\ast}\circ\eta_{A} = f\).

            \item for all~\(f:A\to TB,g:B\to TC\) we
                have~\(g^{\ast}\circ f^{\ast} = (g^{\ast}\circ f)^{\ast}\).
        \end{enumerate}
    \end{definition}
\end{frame}
\end{document}
